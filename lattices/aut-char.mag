// find the automorphism group of a lattice, given a characteristic
// sublattice.

// Let L be a lattice and C a characteristic sublattice.  We then have
// an obvious restriction map Aut L -> Aut C, which is neither injective
// nor surjective in general.  One can calculate the inverse image of
// a single element of Aut C using a Groebner basis computation, which
// gives us the kernel, but the image is not so easy.

// The method used here is just to walk through the lattice of subgroups,
// keeping track of elements that do and don't lift, until we reach the
// correct group.  Is there a better way?

// Convention: we assume that the first d lattice generators span a
// characteristic sublattice.  If this is false, results are likely to be
// nonsense.  I had it in the back of my mind that the first d generators
// should span (the saturation of) the sublattice generated by vectors of
// norm at most n, but the code doesn't assume this.

// The code works (but is a pointless wrapper around Magma's built-in)
// if d = dim L, and should work (except that you would run out of memory)
// if d = 0.

// Example:
/*
d6 := CartanMatrix("d6");
mat8 := DiagonalJoin(d6,Matrix(2,2,[40,1,1,100]));
for i in [3,4] do mat8[i,i+4] := 1; mat8[i+4,i] := 1; end for;
ld6 := LatticeWithGram(d6);
lat := LatticeWithGram(mat8);
aut_lat := aut_char(lat,4); // the first 4 generators give the root lattice
*/

// given a polynomial of degree 2, change the variables to make it diagonal.
function reduce_quad(pol)
  error if Degree(pol) ne 2, "quadratic polynomials only";
  pr := Parent(pol);
  rk := Rank(pr);
  prpr := PolynomialRing(pr,rk);
  chpol := Evaluate(pol,[pr.i+prpr.i: i in [1..rk]]);
  coefs := [MonomialCoefficient(chpol,prpr.i): i in [1..rk]];
  // these are linear equations so Groebner bases are overkill, but ...
  sol := RationalPoints(Scheme(Spec(pr),coefs))[1];
  tr := Evaluate(pol,[pr.i+sol[i]: i in [1..rk]]);
  return tr, sol;
end function;

// find integer solutions to a positive definite quadratic
function solve_quad(pol)
  tr,sol := reduce_quad(pol);
  rk := Rank(Parent(pol));
  lcm := LCM([Denominator(i): i in Eltseq(sol)]);
  lat := LatticeWithGram(SymmetricMatrix(tr-MonomialCoefficient(tr,1)));
  const := -lcm^2*MonomialCoefficient(tr,1);
  pts := [s*x[1]: x in ShortVectors(lat,const,const), s in [1,-1]];
  polpts := [[x[i]/lcm+sol[i]: i in [1..rk]]: x in pts];
  intpts := [x: x in polpts|forall{i: i in x|i in Z}];
  return intpts;
end function;

// lift an automorphism
// conventions: the characteristic sublattice is spanned by the first k
// vectors, so its Gram matrix is the top left k x k submatrix
// the automorphism is given by a matrix A as usual
// we want to lift it to a block matrix [A,0;B,C] where B, C are arbitrary
// except that det C = +-1
function lift(lat,autmat: only_one := false)
  subdim := Nrows(autmat);
  dim := Rank(lat);
  nr := dim-subdim; // "new rank"
  pr := PolynomialRing(Q,dim*(nr));
  chlat := RSpace(pr,dim,ChangeRing(GramMatrix(lat),pr));
  imelts := [&+[r[i]*chlat.i: i in [1..subdim]]: r in Rows(autmat)] cat [&+[pr.(i+dim*(d-1))*chlat.i: i in [1..dim]]: d in [1..nr]];
  conds := {@(imelts[i],imelts[j])-GramMatrix(lat)[i,j]: i,j in [1..dim]@};
  det := Determinant(Matrix([[pr.(dim*d+i): i in [1-(nr)..0]]: d in [1..nr]]));
  An := Spec(pr);
  schs := [Scheme(An,Setseq(Include(conds,det-i))): i in [1,-1]];
  genlift := VerticalJoin(ChangeRing(HorizontalJoin(autmat,ZeroMatrix(Z,subdim,nr)),pr),Matrix(nr,dim,[pr.i: i in [1..dim*nr]]));

  if nr eq 1 then
    pts := {@x: x in RationalPoints(s), s in schs|forall{i: i in Eltseq(x)|i in Z}@};
    lifts := [Evaluate(genlift,Eltseq(i)): i in pts];
    assert forall{n: n in lifts|n*g*Transpose(n) eq g} where g is GramMatrix(lat);
    return lifts;
  end if;
  
    
  lifts := [];
  Qnr := PolynomialRing(Q,nr);
  for s in schs do
    ps := ProjectiveClosure(s);
    rl,torl := RemoveLinearRelations(ps);
    /*pcrl := PrimeComponents(rl);
    pcps := [i@@map<ps->AmbientSpace(i)|DefiningPolynomials(torl)>: i in pcrl];
    aps := [AffinePatch(i,1): i in pcps];*/
    aps := [AffinePatch(Scheme(AmbientSpace(rl),EasyBasis(Ideal(rl)))@@map<ps->AmbientSpace(rl)|DefiningPolynomials(torl)>,1)];
    for p in aps do
      // we do not get a polynomial for the first additional generator
      // we could find it by an elimination ideal calculation
      // these polynomials allow us to limit the image of the extra generators
      // in the quotient by the characteristic sublattice
      good_pols := [{x: x in DefiningPolynomials(p)|Degree(x) eq 2 and forall{i: i in [1..dim*nr]|Degree(x,i) eq 0 or i in [dim*k+nr+1..dim*(k+1)]}}: k in [1..nr-1]];
      assert forall{i: i in good_pols|#i eq 1};
      short_pols := [Evaluate(Rep(good_pols[i]),[0: j in [1..dim*(i+1)-nr]] cat [Qnr.j: j in [1..nr]] cat [0: j in [dim*(i+1)+1..dim*nr]]): i in [1..nr-1]];

      short_sols := [solve_quad(p): p in short_pols];
      short_vecs := [];
      for q in [1..nr-1] do
        short_vecs[q] := {PowerSequence(Z)|};
        for t in short_sols[q] do
          find_pt := Scheme(p,[p.(dim*(q+1)-nr+i)-t[i]: i in [1..nr]]);
          sv := [-MonomialCoefficient(Basis(EliminationIdeal(Ideal(find_pt),{dim*q+i}))[1],1): i in [1..dim-nr]] cat t;
          if forall{i: i in sv|i in Z} then Include(~short_vecs[q],sv); end if;
        end for;
      end for;

      for i in CartesianProduct(short_vecs) do
        p_pt := Scheme(p,[p.(dim*j+k)-i[j,k]: k in [1..dim], j in [1..nr-1]]);
        pts := {@x: x in RationalPoints(p_pt)|forall{i: i in Eltseq(x)|i in Z}@};
        lifts cat:= [Evaluate(genlift,Eltseq(i)): i in pts];
        if only_one and #lifts gt 0 then break s; end if;
      end for;

    end for;
  end for;
  assert forall{n: n in lifts|n*g*Transpose(n) eq g} where g is GramMatrix(lat);
  return lifts;
end function;

// in particular, the kernel is the set of lifts of the trivial automorphism.
// here we take the characteristic subgroup to be spanned by the first d rows.
function aut_char(lat,d)
  if assigned lat`AutomorphismGroup then return lat`AutomorphismGroup; end if;
  if d eq Rank(lat) then return AutomorphismGroup(lat); end if;
  gm := GramMatrix(lat);
  gm_sub := Matrix(d,d,[gm[i,j]: i,j in [1..d]]);
  sublat := LatticeWithGram(gm_sub);
  aut_sub := AutomorphismGroup(sublat);
  ker := lift(lat,Identity(aut_sub));
  lift_gens := [lift(lat,aut_sub.i:only_one): i in [1..Ngens(aut_sub)]];
  if forall{x: x in lift_gens|#x gt 0} then
    // the whole automorphism group lifts
    aut_lat := MatrixGroup<Rank(lat),Z|ker cat [x[1]: x in lift_gens]>;
    assert #aut_lat eq #ker*#aut_sub;
    lat`AutomorphismGroup := aut_lat;
    return aut_lat;
  else
    // we descend through the lattice of subgroups.
    can_lift := AssociativeArray(aut_sub);
    for i in [1..Ngens(aut_sub)] do
      if #lift_gens[i] gt 0 then can_lift[aut_sub.i] := lift_gens[i]; end if;
    end for;
    cant_lift := {@aut_sub.i: i in [1..Ngens(aut_sub)]|#lift_gens[i] eq 0@};
    layers := [[aut_sub]];
    repeat
      lift_sub := sub<aut_sub|Keys(can_lift)>;
      new_gps := [x`subgroup: x in MaximalSubgroups(g), g in layers[#layers]];
      // exclude subgroups that aren't really in the next layer
      new_gps := [x: x in new_gps|forall{v: v in layers[#layers]|not IsConjugateSubgroup(aut_sub,x,v)}];
      // exclude subgroups that are conjugate to others
      new_gps := [new_gps[i]: i in [1..#new_gps]|forall{j: j in [1..#new_gps]|(i le j or not IsConjugate(aut_sub,new_gps[i],new_gps[j]))}];
      // exclude subgroups that don't contain the known subgroup
      new_gps := [x: x in new_gps|IsConjugateSubgroup(aut_sub,x,lift_sub)];
      // exclude subgroups that are conjugate to a subgroup of another one
      // in other words, we want the depth to be the length of the longest
      // chain of subgroups leading to a group, not the shortest
      new_gps := [x: x in new_gps|forall{y: y in new_gps|#y le #x or not IsConjugateSubgroup(aut_sub,y,x)}];
      
      Append(~layers,new_gps);
      for g in new_gps do
        gcons := [g^t: t in Transversal(aut_sub,Normalizer(aut_sub,g))];
        for gc in gcons do
          // exclude subgroups that contain an element we know we can't lift
          if exists{c: c in cant_lift|c in gc} then continue; end if;
          inds := [i: i in [1..Ngens(gc)]|gc.i notin lift_sub];
          lift_gc := [lift(lat,gc.i:only_one): i in inds];
          if forall{l: l in lift_gc|#l gt 0} then
            // we have found the group
            // if it were bigger we would have found it already
            aut_lat := MatrixGroup<Rank(lat),Z|&cat lift_gc,&cat [can_lift[i]: i in Keys(can_lift)]>;
            #sub<aut_sub|Keys(can_lift)>, #aut_lat;
            lat`AutomorphismGroup := aut_lat;
            return aut_lat;
          else
            for i in [1..#inds] do
              if #lift_gc[i] gt 0 then can_lift[gc.inds[i]] := lift_gc[i]; end if;
            end for;
            
            cant_lift join:= {@gc.inds[i]: i in [1..#inds]|#lift_gc[i] eq 0@};
          end if;
        end for;
      end for;
      // if nothing else, we can always lift the trivial automorphism
    until false;
  end if;
end function;

// alternative version where instead of running through the lattice of
// subgroups we just step by the index
// the bookkeeping is simpler, but it might be slower
// or it might not be, since finding maximal subgroups can be arduous.
// My expectation is that in practical cases the index of the image of the
// homomorphism above in the full automorphism group will be small, and that
// would make this one better.
function aut_char_simple(lat,d)
  if assigned lat`AutomorphismGroup then return lat`AutomorphismGroup; end if;
  if d eq Rank(lat) then return AutomorphismGroup(lat); end if;
  gm := GramMatrix(lat);
  gm_sub := Matrix(d,d,[gm[i,j]: i,j in [1..d]]);
  sublat := LatticeWithGram(gm_sub);
  aut_sub := AutomorphismGroup(sublat);
  p := 10;
  repeat
    p := NextPrime(p);
    asp := ChangeRing(aut_sub,GF(p));
  until #aut_sub eq #asp;
  to_asp := hom<aut_sub->asp|[aut_sub.i: i in [1..Ngens(aut_sub)]]>;
  
  ker := lift(lat,Identity(aut_sub));
  lift_gens := [lift(lat,aut_sub.i:only_one): i in [1..Ngens(aut_sub)]];
  if forall{x: x in lift_gens|#x gt 0} then
    // the whole automorphism group lifts
    aut_lat := MatrixGroup<Rank(lat),Z|ker cat [x[1]: x in lift_gens]>;
    assert #aut_lat eq #ker*#aut_sub;
    lat`AutomorphismGroup := aut_lat;
    return aut_lat;
  else
    can_lift := AssociativeArray(aut_sub);
    for i in [1..Ngens(aut_sub)] do
      if #lift_gens[i] gt 0 then can_lift[aut_sub.i] := lift_gens[i]; end if;
    end for;
    cant_lift := {@aut_sub.i: i in [1..Ngens(aut_sub)]|#lift_gens[i] eq 0@};
    pow := 0;
    repeat
      lift_sub := sub<aut_sub|Keys(can_lift)>;
      pow +:= 1;
      // unfortunately the composition tree doesn't seem to help with this
      new_gps := [x`subgroup@@to_asp: x in Subgroups(asp: IndexLimit := 2^pow)|Index(asp,x`subgroup) gt 2^(pow-1)];
      new_gps := [x: x in new_gps|IsConjugateSubgroup(aut_sub,x,lift_sub)];

      for g in new_gps do
        gcons := [g^t: t in Transversal(aut_sub,Normalizer(aut_sub,g))];
        for gc in gcons do
          // exclude subgroups that contain an element we know we can't lift
          if exists{c: c in cant_lift|c in gc} then continue; end if;
          inds := [i: i in [1..Ngens(gc)]|gc.i notin lift_sub];
          lift_gc := [lift(lat,gc.i:only_one): i in inds];
          if forall{l: l in lift_gc|#l gt 0} then
            // we have found the group
            // if it were bigger we would have found it already
            aut_lat := MatrixGroup<Rank(lat),Z|ker,&cat lift_gc,&cat [can_lift[i]: i in Keys(can_lift)]>;
            // #sub<aut_sub|Keys(can_lift)>, #aut_lat;
            lat`AutomorphismGroup := aut_lat;
            return aut_lat;
          else
            for i in [1..#inds] do
              if #lift_gc[i] gt 0 then can_lift[gc.inds[i]] := lift_gc[i]; end if;
            end for;
            
            cant_lift join:= {@gc.inds[i]: i in [1..#inds]|#lift_gc[i] eq 0@};
          end if;
        end for;
      end for;
    until false;
  end if;
end function;

// other variation, better when the index of the liftable subgroup is large
// and the codimension of the characteristic sublattice is small
// we try to build up the group from the bottom by lifting random elements
// until they generate a subgroup close enough to the subgroup that can
// be lifted, then search over coset representatives to get it exactly right
// caution: if the index of the subgroup of Aut(char. sublat.) that can be
// lifted to the full lattice is greater than max_ind, this will run forever
function aut_max_ind(lat,d: max_ind := 100)
  if assigned lat`AutomorphismGroup then return lat`AutomorphismGroup; end if;
  if d eq Rank(lat) then return AutomorphismGroup(lat); end if;
  gm := GramMatrix(lat);
  gm_sub := Matrix(d,d,[gm[i,j]: i,j in [1..d]]);
  sublat := LatticeWithGram(gm_sub);
  aut_sub := AutomorphismGroup(sublat);

  ker := lift(lat,Identity(aut_sub));
  lift_sub := sub<aut_sub|>;
  lifts := ker;
  cant_lift := {@@};
  repeat
    printf ".";
    l := Random(aut_sub);
    if l in lift_sub then continue; end if;
    lg := lift(lat,l:only_one);
    if #lg gt 0 then
      Append(~lifts,lg[1]);
      lift_sub := sub<aut_sub|lift_sub,l>;
      printf " %o ", Index(aut_sub,lift_sub);
    else
      Include(~cant_lift,l);
    end if;
  until Index(aut_sub,lift_sub) le max_ind;
  printf "\n";
  
  tr := {@x: x in Transversal(aut_sub,lift_sub)|x ne Identity(aut_sub)@};

  // the time for these two approaches is about the same
  // the goal is to make a list of pairs [x,y] such that a subgroup
  // containing x must contain y as well, so if y doesn't lift neither does x.

  /*aa := AssociativeArray();
  for i in [1..#tr] do
    gi := sub<aut_sub|lift_sub,tr[i]>;
    if gi in Keys(aa) then Append(~aa[gi],i); else aa[gi] := [i]; end if;
  end for;
  pairs := {@[tr[j],tr[i]]: i in [1..#tr], j in aa[gi], gi in Keys(aa)|tr[i] in gi@};*/

  pairs := {@@};
  for i in [1..#tr] do
    gi := sub<aut_sub|lift_sub,tr[i]>;
    pairs join:= {@[tr[i],tr[j]]: j in [1..#tr]|tr[j] in gi@};
  end for;
  
  while #tr gt 0 do
    v := tr[1];
    tr := tr[2..#tr];
    new_sub := sub<aut_sub|lift_sub,v>;
    if forall{i: i in cant_lift|i notin new_sub} then
      lv := lift(lat,v:only_one);
      if #lv gt 0 then
        Append(~lifts,lv[1]);
        lift_sub := new_sub;
        tr := {@x: x in tr|x notin new_sub@};
      else
        tr := {@x: x in tr|[x,v] notin pairs@};
      end if;
    else
      tr := {@x: x in tr|[x,v] notin pairs@};
      Include(~cant_lift,v);
    end if;
    printf "%o ", #tr;
  end while;
  aut_lat := MatrixGroup<Rank(lat),Z|lifts>;
  assert #aut_lat eq #lift_sub*#ker;
  lat`AutomorphismGroup := aut_lat;
  return aut_lat;
end function;
  
/* unused code:
      for p in CartesianProduct([Set(i): i in short
    if exists(pol2){x: x in DefiningPolynomials(p)|Degree(x) eq 2 and forall{i: i in [1..(dim-1)*nr]|Degree(x,i) eq 0}} then
      // assert forall{i: i in DefiningPolynomials(p)|i eq pol2 or Degree(i) eq 1};
      vars := [x: x in [1..Dimension(An)]|Degree(pol2,x) gt 0];
      Qv := PolynomialRing(Q,#vars);
      short_pol2 := Evaluate(pol2,[i in vars select Qv.Index(vars,i) else 0: i in [1..dim*nr]]);
      pol2_sols := solve_quad(short_pol2);
      pts := &join [RationalPoints(Scheme(p,[An.i-pt[Index(vars,i)]: i in vars])): pt in pol2_sols];
    else
      pts := RationalPoints(p);
    end if;
    pts := {@x: x in pts|forall{i: i in Eltseq(x)|i in Z}@};
    new_lifts := [Evaluate(genlift,Eltseq(i)): i in pts];
    assert forall{n: n in new_lifts|n*g*Transpose(n) eq g} where g is GramMatrix(lat);
    lifts cat:= new_lifts;
  end for;
  return lifts;
end function;

*/
