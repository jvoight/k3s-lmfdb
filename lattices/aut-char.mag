// find the automorphism group of a lattice, given a characteristic
// sublattice.

// Let L be a lattice and C a characteristic sublattice.  We then have
// an obvious restriction map Aut L -> Aut C, which is neither injective
// nor surjective in general.  One can calculate the inverse image of
// a single element of Aut C using a Groebner basis computation, which
// gives us the kernel, but the image is not so easy.

// The method used here is just to walk through the lattice of subgroups,
// keeping track of elements that do and don't lift, until we reach the
// correct group.  Is there a better way?

// Convention: we assume that the first d lattice generators span a
// characteristic sublattice.  If this is false, results are likely to be
// nonsense.  I had it in the back of my mind that the first d generators
// should span (the saturation of) the sublattice generated by vectors of
// norm at most n, but the code doesn't assume this.

// The code should work (but be no better than Magma's built-in) if d = 0,
// and should work (but be really slow) if d = dim L.

// Example:
/*
d6 := CartanMatrix("d6");
mat8 := DiagonalJoin(d6,Matrix(2,2,[40,1,1,100]));
for i in [3,4] do mat8[i,i+4] := 1; mat8[i+4,i] := 1; end for;
ld6 := LatticeWithGram(d6);
lat := LatticeWithGram(mat8);
aut_lat := aut_char(lat,4); // the first 4 generators give the root lattice
*/

// given a polynomial of degree 2, change the variables to make it diagonal.
function reduce_quad(pol)
  error if Degree(pol) ne 2, "quadratic polynomials only";
  pr := Parent(pol);
  rk := Rank(pr);
  prpr := PolynomialRing(pr,rk);
  chpol := Evaluate(pol,[pr.i+prpr.i: i in [1..rk]]);
  coefs := [MonomialCoefficient(chpol,prpr.i): i in [1..rk]];
  // these are linear equations so Groebner bases are overkill, but ...
  sol := RationalPoints(Scheme(Spec(pr),coefs))[1];
  tr := Evaluate(pol,[pr.i+sol[i]: i in [1..rk]]);
  return tr, sol;
end function;

// find integer solutions to a positive definite quadratic
function solve_quad(pol)
  tr,sol := reduce_quad(pol);
  rk := Rank(Parent(pol));
  lcm := LCM([Denominator(i): i in Eltseq(sol)]);
  lat := LatticeWithGram(SymmetricMatrix(tr-MonomialCoefficient(tr,1)));
  const := -lcm^2*MonomialCoefficient(tr,1);
  pts := [s*x[1]: x in ShortVectors(lat,const,const), s in [1,-1]];
  polpts := [[x[i]/lcm+sol[i]: i in [1..rk]]: x in pts];
  intpts := [x: x in polpts|forall{i: i in x|i in Z}];
  return intpts;
end function;

// lift an automorphism
// conventions: the characteristic sublattice is spanned by the first k
// vectors, so its Gram matrix is the top left k x k submatrix
// the automorphism is given by a matrix A as usual
// we want to lift it to a block matrix [A,0;B,C] where B, C are arbitrary
// except that det C = +-1
function lift(lat,autmat)
  subdim := Nrows(autmat);
  dim := Rank(lat);
  nr := dim-subdim; // "new rank"
  pr := PolynomialRing(Q,dim*(nr));
  chlat := RSpace(pr,dim,ChangeRing(GramMatrix(lat),pr));
  imelts := [&+[r[i]*chlat.i: i in [1..subdim]]: r in Rows(autmat)] cat [&+[pr.(i+dim*(d-1))*chlat.i: i in [1..dim]]: d in [1..nr]];
  conds := {@(imelts[i],imelts[j])-GramMatrix(lat)[i,j]: i,j in [1..dim]@};
  det := Determinant(Matrix([[pr.(dim*d+i): i in [1-(nr)..0]]: d in [1..nr]]));
  An := Spec(pr);
  schs := [Scheme(An,Setseq(Include(conds,det-i))): i in [1,-1]];
  genlift := VerticalJoin(ChangeRing(HorizontalJoin(autmat,ZeroMatrix(Z,subdim,nr)),pr),Matrix(nr,dim,[pr.i: i in [1..dim*nr]]));
  
  lifts := [];
  Qnr := PolynomialRing(Q,nr);
  for s in schs, p in PrimeComponents(s) do
    if exists(pol2){x: x in DefiningPolynomials(p)|Degree(x) eq 2} then
      assert forall{i: i in DefiningPolynomials(p)|i eq pol2 or Degree(i) eq 1};
      vars := [x: x in [1..Dimension(An)]|Degree(pol2,x) gt 0];
      assert #vars eq nr;
      short_pol2 := Evaluate(pol2,[i in vars select Qnr.Index(vars,i) else 0: i in [1..dim*nr]]);
      pol2_sols := solve_quad(short_pol2);
      pts := &join [RationalPoints(Scheme(p,[An.i-pt[Index(vars,i)]: i in vars])): pt in pol2_sols];
    else
      pts := RationalPoints(p);
    end if;
    pts := {@x: x in pts|forall{i: i in Eltseq(x)|i in Z}@};
    new_lifts := [Evaluate(genlift,Eltseq(i)): i in pts];
    assert forall{n: n in new_lifts|n*g*Transpose(n) eq g} where g is GramMatrix(lat);
    lifts cat:= new_lifts;
  end for;
  return lifts;
end function;

// in particular, the kernel is the set of lifts of the trivial automorphism.
// here we take the characteristic subgroup to be spanned by the first d rows.
function aut_char(lat,d)
  gm := GramMatrix(lat);
  gm_sub := Matrix(d,d,[gm[i,j]: i,j in [1..d]]);
  sublat := LatticeWithGram(gm_sub);
  aut_sub := AutomorphismGroup(sublat);
  ker := lift(lat,Identity(aut_sub));
  lift_gens := [lift(lat,aut_sub.i): i in [1..Ngens(aut_sub)]];
  if forall{x: x in lift_gens|#x gt 0} then
    // the whole automorphism group lifts
    aut_lat := MatrixGroup<Rank(lat),Z|ker cat [x[1]: x in lift_gens]>;
    assert #aut_lat eq #ker*#aut_sub;
    return aut_lat;
  else
    // we descend through the lattice of subgroups.
    can_lift := AssociativeArray(aut_sub);
    for i in [1..Ngens(aut_sub)] do
      if #lift_gens[i] gt 0 then can_lift[aut_sub.i] := lift_gens[i]; end if;
    end for;
    cant_lift := {@aut_sub.i: i in [1..Ngens(aut_sub)]|#lift_gens[i] eq 0@};
    layers := [[aut_sub]];
    repeat
      lift_sub := sub<aut_sub|Keys(can_lift)>;
      new_gps := [x`subgroup: x in MaximalSubgroups(g), g in layers[#layers]];
      // exclude subgroups that aren't really in the next layer
      new_gps := [x: x in new_gps|forall{v: v in layers[#layers]|not IsConjugateSubgroup(aut_sub,x,v)}];
      // exclude subgroups that are conjugate to others
      new_gps := [new_gps[i]: i in [1..#new_gps]|forall{j: j in [1..#new_gps]|(i le j or not IsConjugate(aut_sub,new_gps[i],new_gps[j]))}];
      // exclude subgroups that don't contain the known subgroup
      new_gps := [x: x in new_gps|IsConjugateSubgroup(aut_sub,x,lift_sub)];
      // exclude subgroups that are conjugate to a subgroup of another one
      // in other words, we want the depth to be the length of the longest
      // chain of subgroups leading to a group, not the shortest
      new_gps := [x: x in new_gps|forall{y: y in new_gps|#y le #x or not IsConjugateSubgroup(aut_sub,y,x)}];
      
      Append(~layers,new_gps);
      for g in new_gps do
        gcons := [g^t: t in Transversal(aut_sub,Normalizer(aut_sub,g))];
        for gc in gcons do
          // exclude subgroups that contain an element we know we can't lift
          if exists{c: c in cant_lift|c in gc} then continue; end if;
          inds := [i: i in [1..Ngens(gc)]|gc.i notin Keys(can_lift)];
          lift_gc := [lift(lat,gc.i): i in inds];
          if forall{l: l in lift_gc|#l gt 0} then
            // we have found the group
            // if it were bigger we would have found it already
            aut_lat := MatrixGroup<Rank(lat),Z|&cat lift_gc,&cat [can_lift[i]: i in Keys(can_lift)]>;
            #sub<aut_sub|Keys(can_lift)>, #aut_lat;
            return aut_lat;
          else
            for i in [1..#inds] do
              if #lift_gc[i] gt 0 then can_lift[gc.inds[i]] := lift_gc[i]; end if;
            end for;
            
            cant_lift join:= {@gc.inds[i]: i in [1..#inds]|#lift_gc[i] eq 0@};
          end if;
        end for;
      end for;
      // if nothing else, we can always lift the trivial automorphism
    until false;
  end if;
end function;
