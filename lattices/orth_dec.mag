Z := Integers();

// let's try to implement the same idea in Magma
// for some reason Magma's OrthogonalComplement only works for LatNF, not Lat
function orth_comp(rs,sub)
  Zk := RSpace(Z,Dimension(sub));
  tok := hom<rs->Zk|[[(x,y): y in Basis(sub)]: x in Basis(rs)]>;
  ker := Kernel(tok);
  // we already have the inclusion map
  return ker,RSpace(Z,Dimension(ker),GramMatrix(ker));
end function;

// this is an example
// it decomposes into components of rank 5 and 2
// lat := LatticeWithGram(SymmetricMatrix([6,-9,16,-3,7,18,1,-2,-8,8,0,0,-7,4,4,1,-1,0,-2,0,2,-1,2,1,0,0,0,2]));

// improvement: if we have something of codimension 1 contained in a
// component that is not a component, then the lattice is indecomposable
// more generally, if our components add to codimension 1 but the saturation
// of their sum is not a component, the lattice is indecomposable

// this is much the same algorithm as in arXiv:0604320, by Hemkemeier-Vallentin
function orth_dec(lat: norm_bd := Infinity())
  if Rank(lat) eq 0 then return [lat]; end if;
  mat := GramMatrix(lat);
  dim := Rank(lat);
  lll,tolll := LLLGram(mat);
  lat_lll := LatticeWithGram(lll);
  bd := Min(Max(Diagonal(lll)),norm_bd);
  components := [];
  rs := RSpace(Z,dim,lll);
  done := false;
  ret_val := [lat]; // if we fail, we fail
  
  sub_rs := sub<rs|>;

  for l in [1..bd] do
    sv := [rs|x[1]: x in ShortVectors(lat_lll,l,l)];
    if #sv gt 0 then vprint Lattice, 1: "considering", #sv, "vectors of norm", l; end if;
    for v in sv do
      if v notin sub_rs then
        vprint Lattice, 2: "looking at vector", v;
        nonorth_comps := [x: x in components|exists{i: i in Basis(x)|(rs!v,i) ne 0}];
        vprint Lattice, 2: "found", #nonorth_comps, "nonorthogonal component"*(#nonorth_comps eq 1 select "" else "s");
        new_comp := sub<rs|nonorth_comps,v>;
        new_orth := orth_comp(rs,new_comp);
        // why doesn't Saturation give you a subspace of the same space?
        sat_comp := sub<rs|Basis(Saturation(new_comp))>;
        if sat_comp eq rs or (Rank(sat_comp) eq Rank(rs)-1 and sub<rs|new_orth,sat_comp> ne rs) then
          done := true; ret_val := [lat];/*[LatticeWithGram(GramMatrix(rs))];*/
          break l;
        end if; // done
        if sub<rs|new_orth,sat_comp> eq rs then
          // we have found a component; recursively find the rest
          vprint Lattice, 1: "splitting into two factors";
          orth_lat := LatticeWithGram(GramMatrix(new_orth));
          orth_rs := RSpace(Z,Rank(new_orth),GramMatrix(new_orth));
          orth_comps := orth_dec(orth_lat:norm_bd := norm_bd);
          orth_comps_lll := Append([sub<lat_lll|[&+[v[i]*Basis(new_orth)[i]: i in [1..Dimension(orth_lat)]]: v in Basis(c)]>: c in orth_comps],sub<lat_lll|Basis(sat_comp)>);
          orth_comps_lat := [sub<lat|[lat|Vector(v)*tolll: v in Basis(c)]>: c in orth_comps_lll];
          assert forall{x: x,y in orth_comps_lat|x eq y or forall{a: a in Basis(x), b in Basis(y)|(a,b) eq 0}};
          assert sub<lat|orth_comps_lat> eq lat;
          done := true; ret_val := orth_comps_lat;
          break l;
        else
          vprint Lattice, 2: "combining", #nonorth_comps, "component"*(#nonorth_comps eq 1 select "" else "s"), "with a new one";
          components := Append([PowerStructure(ModTupRng)|x: x in components|x notin nonorth_comps],sat_comp);
          if &+[Rank(i): i in components] eq Rank(rs)-1 then
            vprint Lattice, 2: "examining a codimension 1 situation";
            sum_comps := sub<rs|components>;
            sat_sum_comps := sub<rs|Basis(Saturation(sum_comps))>;
            orth_sub := orth_comp(rs,sat_sum_comps);
            // can we do better than this?
            if sub<rs|sat_sum_comps,orth_sub> eq rs then
              // we have found a decomposition
              // unfortunately we need this silly PowerStructure, to stop
              // Magma from deciding that the dimension is part of the type
              od_ssc := [PowerStructure(ModTupRng)|sub<rs|Basis(i)>: i in orth_dec(sat_sum_comps:norm_bd := norm_bd)];
              rso := sub<rs|orth_sub>;
              orth_comps_lll := Append(od_ssc,rso);
              orth_comps_lat := [sub<lat|[lat|Vector(v)*tolll: v in Basis(c)]>: c in orth_comps_lll];
              assert forall{i: a in Basis(i), b in Basis(j), i,j in orth_comps_lat|i eq j or (a,b) eq 0};
              done := true; ret_val := orth_comps_lat;
              break l;
            elif #components eq 1 then
              done := true; ret_val := [lat];
              break l;
            end if;
            // otherwise we can't conclude yet; maybe there are two D_8
            // components with an element of norm 4 bridging them
          end if;
          // sub_rs := sub<rs|Basis(Saturation(sub<rs|sub_rs,v>))>;
          sub_rs := sub<rs|sub_rs,v>;
          if sub_rs eq rs then
            orig_cps := [sub<lat|[v*Transpose(lll): v in Basis(r)]>: r in components];
            try grams := [GramMatrix(i): i in orig_cps]; catch e "failed on lattice", lat; error "foo"; end try;
            done := true; ret_val := orig_cps;
            break l;
          end if;
        end if;
      end if;
    end for;
  end for;

  if norm_bd ge Max(Diagonal(lll)) and not done then
    vprint Lattice, 2: "!!! failed to find orthogonal decomposition";
  end if;
  return ret_val;
end function;

intrinsic OrthogonalDecompositionFaster(lat::Lat : norm_bd := Infinity()) -> SeqEnum[Lat]
{Return the orthogonal decomposition of the lattice lat with norm bound norm_bd.}
    return orth_dec(lat: norm_bd := norm_bd);
end intrinsic;

function split_1(lat)
  sv := ShortVectors(lat,1,1);
  sub_1 := sub<lat|[x[1]: x in sv]>;
  assert IsIsomorphic(sub_1,StandardLattice(Dimension(sub_1)));
  rs := RSpace(Z,Dimension(lat),GramMatrix(lat));
  orth_1 := orth_comp(rs,sub<rs|[rs!Eltseq(i): i in Basis(sub_1)]>);
  orth_lat := sub<lat|[lat!Eltseq(i): i in Basis(orth_comp)]>;
  return orth_1, orth_lat;
end function;

function root_string(lat)
  sv := ShortVectors(lat,2,2);
  sub_2 := LatticeWithGram(GramMatrix(sub<lat|[x[1]: x in sv]>));
  od := orth_dec(sub_2);
  root_str := "";
  for rl in od do
    if Rank(rl) in [6..8] and Determinant(rl) eq 9-Rank(rl) then
      str := Sprintf("E%o",Rank(rl));
    elif Rank(rl) ge 4 and Determinant(rl) eq 4 then
      str := Sprintf("D%o",Rank(rl));
    elif Determinant(rl) eq Rank(rl)+1 then
      str := Sprintf("A%o",Rank(rl));
    else
      error "unknown root lattice";
    end if;
    assert IsIsomorphic(rl,LatticeWithGram(CartanMatrix(str)));
    root_str *:= str;
  end for;
  return root_str;
end function;
