// function to enumerate a genus using canonical forms
Z := Integers();
Q := Rationals();
load "aut-char.mag";
if assigned orth_comp then delete orth_comp; end if;
import "orth_dec.mag": orth_comp;
Attach("canonical_form.m");
Attach("my_neighbors.m");

// A very quick lattice hash.  This is better with a faster
// OrthogonalDecomposition (cf. my email)
function root_sub(lat)
  rl := {*Strings()|*};
  tor := [];
  sl := sub<lat|[x[1]: x in ShortVectors(lat,2,2)]>;
  if Rank(sl) eq 0 then od := []; else
    Zn := RSpace(Z,Dimension(lat));
    slzn := sub<Zn|[Eltseq(i): i in ShortestVectors(lat)]>;
    tor := Moduli(Saturation(slzn)/slzn);
    od := OrthogonalDecomposition(sl);
  end if;
  for i in od do
    sdi := IntegerToString(Dimension(i));
    for l in ["A","D","E"] do
      if IsIsomorphic(i,LatticeWithGram(CartanMatrix(l*sdi))) then
        Include(~rl,l*sdi);
        continue i;
      end if;
    end for;
    error "impossible root lattice", Eltseq(GramMatrix(lat));
  end for;
  return rl,tor,#ShortVectors(lat,4,4);
end function;

// Function to enumerate the p-neighbourhood of a lattice using the
// canonical form of DS-H-V-vW, as implemented in canonical_form.m.
// Arguments:

// pd: the lattice
// bd: stop after considering this number of lattices
// p: the prime for p-neighbours
// done: initial list of lattices in the genus
// silent: stops the code from babbling (overridden by "show")
// aut_gp_fn, nb_fn, cf_fn: custom functions for finding Aut(L),
// the p-neighbours of a lattice, and a canonical form
// thorough included for backward compatibility

scaled_dual := func<l|LatticeWithGram(ChangeRing(LCM([Denominator(i): i in Eltseq(g)])*g,Z)) where g is GramMatrix(Dual(l))>;
Zx := PolynomialRing(Z);

// things I was hoping would distinguish lattices
// SuccessiveMinima doesn't work, because Magma crashes when it might be useful
// this does distinguish things, but may not make the code faster
function genera_shortest(l)
  sv := ShortestVectors(l);
  ocsv := [LatticeWithGram(GramMatrix(orth_comp(r,sub<r|Eltseq(i)>))): i in ShortestVectors(l)] where r is RSpace(Z,Rank(l),GramMatrix(l));
  gens := {*Genus(i): i in ocsv*};
  return gens;
end function;

// https://www.math.rwth-aachen.de/~Gabriele.Nebe/LATTICES/bacher.html
// doesn't seem to help much
function bacher(l: nm := Minimum(l))
  usv := [x[1]: x in ShortVectors(l,nm,nm)];
  sv := {@s*v: s in [1,-1], v in usv@};
  pairs := {@{sv[x],sv[y]}: y in [x+1..#sv], x in [1..#sv]|(sv[x],sv[y]) eq nm/2@};
  bp := Zx!0;
  for v in usv do
    hv := {x: x in sv|{x,v} in pairs};
    ps := {x: x in Subsets(hv,2)|x in pairs};
    bp +:= Zx.1^#ps;
  end for;
  return bp;
end function;

// this is a strong invariant but slow to calculate
function pairs_to_n(l: n := 3)
  vton := [];
  i := 1;
  repeat
    vi := {@x[1]: x in ShortVectors(l,i,i)@};
    if #vi gt 0 then Append(~vton,vi); end if;
    i +:= 1;
  until #vton eq n;
  pairs := [{*AbsoluteValue((x,y)): x in vton[i], y in vton[j]*}: j in [i..n], i in [1..n]];
  return pairs;
end function;

// bd := Infinity(); p := 2; done := {@@}; silent := false; aut_gp_fn := aut_faster; nb_fn := newNeighbours; cf_fn := func<x|CanonicalForm(GramMatrix(x))>; hash := easy_hash; find_canonical := false;
stoi := func<l,i|sub<l|[x[1]: x in ShortVectors(l,i)]>>;
easy_hash := func<x|<IsEven(x) select "even" else "odd",a,b,c,d,/*#aut_faster(x),*/ThetaSeries(x,(IsEven(x) select 200 div Dimension(x) else 100 div Dimension(x))),ThetaSeries(dl,(IsEven(dl) select 200 div Dimension(dl) else 100 div Dimension(dl)))> where dl is scaled_dual(x) where a,b,c is root_sub(x) where d is [Rank(stoi(x,i)): i in [1..6]]>;
// further improvement: only compute canonical form when we need it,
// unless find_canonical is set to true
// function list_genus(pd: bd := Infinity(), p := 2, done := {@@}, silent := false, aut_gp_fn := AutomorphismGroup, nb_fn := Neighbours, cf_fn := func<x|CanonicalForm(GramMatrix(x))>, hash := easy_hash, thorough := true, find_canonical := false)

// for now the code does compute canonical forms as a method of isomorphism
// testing when the hash fails.  Maybe I could replace this by some
// other isomorphism test, but would it really be easier?
function list_genus(pd: bd := Infinity(), p := 2, done := {@@}, silent := false, aut_gp_fn := aut_faster, nb_fn := newNeighbours, cf_fn := func<x|CanonicalForm(GramMatrix(x))>, hash := easy_hash, thorough := true, find_canonical := false)
  _ := aut_gp_fn(pd);
  g := Genus(pd);
  mass := Mass(pd);
  todo := {@pd@}; rss := [];
  cp := Cputime(); ct := 0;
  mass_left := mass;
  hashes := [hash(pd)];
  found_hashes := [];
  used_hashes := {@@};
  cf := cf_fn(pd); // placeholder
  can_forms := []; // I don't think we spend much time comparing them
  while #todo gt 0 and #done lt bd and mass_left gt 0 do
    good_inds := [x: x in [1..#todo]|hashes[x] notin found_hashes];
    ct +:= 1;
    if not silent then
      if ct mod 100 eq 0 then
        printf "%o done, %o found, %o left, time taken %o\n", ct, #done, #todo, Cputime(cp);
      else vprintf Genus,2: (#good_inds gt 0 select "+" else "*");
      end if;
    end if;
    if #good_inds gt 0 then ind := Random(good_inds);
    else
      // select one at random, but spread things out by taking a hash we
      // haven't used recently
      if #used_hashes ge #Set(hashes) then
        used_hashes := {@@};
        if not silent then vprintf Genus,2: "h"; end if;
      end if;
      ind := random{x: x in [1..#todo]|hashes[x] notin used_hashes};
      Include(~used_hashes,hashes[ind]);
    end if;
    // ind := (#good_inds gt 0 select Random(good_inds) else Random(1,#todo));
    l := todo[ind];
    if find_canonical or #good_inds eq 0 then
      cf := cf_fn(l);
      assert #good_inds eq 0 or cf notin can_forms;
    end if; 
    todo := {@todo[i]: i in Remove([1..#todo],ind)@};
    the_hash := hashes[ind];
    Remove(~hashes,ind);
    new_hash := the_hash notin found_hashes;
    if new_hash then
      is_new := true;
    else
      if not find_canonical then // we have to after all
        cf := cf_fn(l);
        is_new := true;
        for i in [1..#found_hashes] do
          if found_hashes[i] eq the_hash then
            if not IsDefined(can_forms,i) then can_forms[i] := cf_fn(done[i]); end if;
            if can_forms[i] eq cf then is_new := false; break i; end if;
          end if;
        end for;
      end if;
    end if;
    if is_new then
      vprint Lattice: "found new lattice with Gram matrix", Eltseq(GramMatrix(l));
      Include(~done,l);
      if find_canonical or not new_hash then
        can_forms[#done] := cf;
      end if;
      Append(~found_hashes,the_hash);
      vprint Lattice, 2: "computing automorphism group of lattice with Gram matrix", Eltseq(GramMatrix(l));
      ag := aut_gp_fn(l);
      mass_left -:= 1/#ag;
      if not silent then <<a,b,c> where a,b,c is root_sub(l),RealField(5)!(mass_left/mass), #l`AutomorphismGroup>; end if;
      if mass_left eq 0 and find_canonical then
        g`Representatives := done; 
      else
        nlat := {@LatticeWithGram(GramMatrix(n)): n in nb_fn(l,p)@};
        nlat := {@n: n in nlat|n notin done and n notin todo@};
        todo join:= nlat;
        hashes cat:= [hash(i): i in nlat];
      end if;
    end if;
    assert #todo eq #hashes;
  end while;
  if mass_left gt 0 then "warning: finished exploring the graph but still missing", mass_left, "of mass; consider rerunning with larger p"; end if;
  return done,can_forms,g;
end function;

/*
load "neighbours_canonical.mag";
l := LatticeWithGram(CartanMatrix("d8d8"));
SetVerbose("Lattice",2);
SetVerbose("CanonicalForm",2);
nb := list_genus(l:nb_fn := newNeighbours,aut_gp_fn := aut_faster);
*/

// Unfortunately the CanonicalForm intrinsic that comes with Magma
// is not genuinely canonical.
// Here are two 11 x 11 Gram matrices that define isomorphic lattices:
/*bad_mats := [[ 2, 0, 1, -1, -1, -1, -1, -2, -1, -1, -1, 0, 4, -1, 1, 0, 0, 0, 1, 0, 0, -1, 1, -1, 2, -1, 0, 0, 0, -2, 0, 0, 0, -1, 1, -1, 2, 1, 1, 1, 2, 1, 1, -1, -1, 0, 0, 1, 3, 2, 2, 1, 1, 1, 1, -1, 0, 0, 1, 2, 3, 1, 2, 1, 2, 2, -1, 0, 0, 1, 2, 1, 3, 1, 2, 1, 0, -2, 1, -2, 2, 1, 2, 1, 5, 2, 2, 2, -1, 0, 0, 1, 1, 1, 2, 2, 3, 2, 1, -1, 0, 0, 1, 1, 2, 1, 2, 2, 3, 2, -1, -1, 0, -1, 1, 2, 0, 2, 1, 2, 6 ],
             [ 2, 1, -1, -1, -1, 0, 0, 1, -1, -2, -2, 1, 2, -1, 0, 0, 0, 0, 1, 0, 0, 0, -1, -1, 2, 1, 1, 0, 0, 0, 1, 2, 2, -1, 0, 1, 3, 2, 1, -1, 0, 2, 2, 3, -1, 0,1, 2, 3, 0, -1, 0, 2, 3, 3, 0, 0, 0, 1, 0, 2, -1, 0, 0, -3, -2, 0, 0, 0, -1,-1, -1, 2, 0, -1, 2, 2, 1, 1, 0, 0, 0, 0, 0, 4, 0, 0, 0, -1, 0, 1, 2, 2, 0, -1, 0, 3, 3, 3, -2, 0, 2, 2, 3, -3, 2, 0, 3, 12, 11, -2, 0, 2, 3, 3, -2, 2, 0, 3, 11, 12 ]];
bad_lats := [LatticeWithGram(Matrix(11,11,i)): i in bad_mats];
assert IsIsomorphic(bad_lats[1],bad_lats[2]);
assert CanonicalForm(bad_lats[1]) ne CanonicalForm(bad_lats[2]);
*/
// Update: it now works, using the new intrinsic in canonical_form.m.

// a lattice that causes problems for the canonical form:
// badl := LatticeWithGram(Matrix([[2,1,1,-1,-1,1,-1,-1,0,1,1,2,1,1,0,2],[1,2,1,-1,-1,1,-1,0,0,0,0,2,1,1,0,2],[1,1,2,-1,-1,1,-1,-1,-1,1,1,2,1,1,0,2],[-1,-1,-1,2,1,-1,1,1,1,0,0,-2,-1,-1,0,-2],[-1,-1,-1,1,2,-1,1,0,1,-1,-1,-2,-1,-1,0,-2],[1,1,1,-1,-1,2,-1,0,-1,0,0,2,1,1,0,2],[-1,-1,-1,1,1,-1,2,0,1,0,0,-2,-1,-1,0,-2],[-1,0,-1,1,0,0,0,4,1,-1,-1,-1,0,-1,0,0],[0,0,-1,1,1,-1,1,1,4,0,0,-1,0,-1,0,-2],[1,0,1,0,-1,0,0,-1,0,4,3,1,0,0,1,1],[1,0,1,0,-1,0,0,-1,0,3,4,1,0,0,1,1],[2,2,2,-2,-2,2,-2,-1,-1,1,1,4,2,2,0,3],[1,1,1,-1,-1,1,-1,0,0,0,0,2,2,1,0,1],[1,1,1,-1,-1,1,-1,-1,-1,0,0,2,1,2,0,1],[0,0,0,0,0,0,0,0,0,1,1,0,0,0,2,0],[2,2,2,-2,-2,2,-2,0,-2,1,1,3,1,1,0,6]]));
