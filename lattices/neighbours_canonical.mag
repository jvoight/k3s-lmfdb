// function to enumerate a genus using canonical forms
Z := Integers();
Q := Rationals();
/*Attach("aut-char.mag");
// import "aut-char.mag":AutomorphismGroupFaster;
Attach("orth_dec.mag");
// import "orth_dec.mag":OrthogonalComplementFaster;
// if assigned orth_comp then delete orth_comp; end if;
// import "orth_dec.mag": orth_comp;
Attach("canonical_form.m");
// import "canonical_form.m":CanonicalForm;
Attach("my_neighbors.m");
// import "my_neighbors.m":newNeighbours;*/
// AttachSpec("lattices.spec");

// A very quick lattice hash.  This is better with a faster
// OrthogonalDecomposition (cf. my email)
function root_sub(lat)
  rl := {*Strings()|*};
  tor := [Z|];
  sl := sub<lat|[x[1]: x in ShortVectors(lat,2,2)]>;
  if Rank(sl) eq 0 then od := []; else
    Zn := RSpace(Z,Dimension(lat));
    slzn := sub<Zn|[Eltseq(i): i in ShortestVectors(lat)]>;
    tor := Moduli(Saturation(slzn)/slzn);
    od := OrthogonalDecomposition(sl);
  end if;
  for i in od do
    sdi := IntegerToString(Dimension(i));
    for l in ["A","D","E"] do
      if IsIsomorphic(i,LatticeWithGram(CartanMatrix(l*sdi))) then
        Include(~rl,l*sdi);
        continue i;
      end if;
    end for;
    error "impossible root lattice", Eltseq(GramMatrix(lat));
  end for;
  return rl,tor,#ShortVectors(lat,4,4);
end function;

// the BV-invariant, as described in Gaetan Chenevier's talk.
function bv(lat: bd := 3, p := 0)
  sv := [x[1]: x in ShortVectors(lat,bd*(IsEven(lat) select 2 else 1))];
  mat := SymmetricMatrix((p eq 0 select Z else GF(p)),[(sv[i],sv[j]) mod 2: i in [1..j], j in [1..#sv]]);
  matsq := mat^2;
  bv_inv := {*Multiset(Eltseq(i)): i in Rows(matsq)*};
  return bv_inv;
end function;
  
// Function to enumerate the p-neighbourhood of a lattice using the
// canonical form of DS-H-V-vW, as implemented in canonical_form.m.
// Arguments:

// pd: the lattice
// bd: stop after considering this number of lattices
// p: the prime for p-neighbours
// done: initial list of lattices in the genus
// silent: stops the code from babbling (overridden by "show")
// aut_gp_fn, nb_fn, cf_fn: custom functions for finding Aut(L),
// the p-neighbours of a lattice, and a canonical form
// thorough included for backward compatibility

scaled_dual := func<l|LatticeWithGram(ChangeRing(LCM([Denominator(i): i in Eltseq(g)])*g,Z)) where g is GramMatrix(Dual(l))>;
Zx := PolynomialRing(Z);

// things I was hoping would distinguish lattices
// SuccessiveMinima doesn't work, because Magma crashes when it might be useful
// this does distinguish things, but may not make the code faster
/*function genera_shortest(l)
  sv := ShortestVectors(l);
  ocsv := [LatticeWithGram(GramMatrix(OrthogonalComplementFaster(r,sub<r|Eltseq(i)>))): i in ShortestVectors(l)] where r is RSpace(Z,Rank(l),GramMatrix(l));
  gens := {*Genus(i): i in ocsv*};
  return gens;
end function;*/

// https://www.math.rwth-aachen.de/~Gabriele.Nebe/LATTICES/bacher.html
// doesn't seem to help much
function bacher(l: nm := Minimum(l))
  usv := [x[1]: x in ShortVectors(l,nm,nm)];
  sv := {@s*v: s in [1,-1], v in usv@};
  pairs := {@{sv[x],sv[y]}: y in [x+1..#sv], x in [1..#sv]|(sv[x],sv[y]) eq nm/2@};
  bp := Zx!0;
  for v in usv do
    hv := {x: x in sv|{x,v} in pairs};
    ps := {x: x in Subsets(hv,2)|x in pairs};
    bp +:= Zx.1^#ps;
  end for;
  return bp;
end function;

// this is a strong invariant but slow to calculate
function pairs_to_n(l: n := 3)
  vton := [];
  i := 1;
  repeat
    vi := {@x[1]: x in ShortVectors(l,i,i)@};
    if #vi gt 0 then Append(~vton,vi); end if;
    i +:= 1;
  until #vton eq n;
  pairs := [{*AbsoluteValue((x,y)): x in vton[i], y in vton[j]*}: j in [i..n], i in [1..n]];
  return pairs;
end function;

// bd := Infinity(); p := 2; done := {@@}; silent := false; aut_gp_fn := AutomorphismGroupFaster; nb_fn := newNeighbours; cf_fn := func<x|CanonicalForm(GramMatrix(x))>; hash := easy_hash; find_canonical := false;
stoi := func<l,i|sub<l|[x[1]: x in ShortVectors(l,i)]>>;
easy_hash := func<x|<IsEven(x) select "even" else "odd",a,b,c,d,/*#AutomorphismGroupFaster(x),*/ThetaSeries(x,(IsEven(x) select 100 div Dimension(x) else 50 div Dimension(x))),ThetaSeries(dl,(IsEven(dl) select 100 div Dimension(dl) else 50 div Dimension(dl)))> where dl is scaled_dual(x) where a,b,c is root_sub(x) where d is [Rank(stoi(x,i)): i in [1..6]]>;
hash_bv := func<x|Append(easy_hash(x),bv(x))>;
// further improvement: only compute canonical form when we need it,
// unless find_canonical is set to true
// function list_genus(pd: bd := Infinity(), p := 2, done := {@@}, silent := false, aut_gp_fn := AutomorphismGroup, nb_fn := newNeighbours, cf_fn := func<x|CanonicalForm(GramMatrix(x))>, hash := easy_hash, thorough := true, find_canonical := false)

// for now the code does compute canonical forms as a method of isomorphism
// testing when the hash fails.  Maybe I could replace this by some
// other isomorphism test, but would it really be easier?
/* function list_genus_old(pd: bd := Infinity(), p := 2, done := {@@}, silent := false, aut_gp_fn := AutomorphismGroupFaster, nb_fn := newNeighbours, cf_fn := func<x|CanonicalForm(GramMatrix(x))>, hash := easy_hash, thorough := true, find_canonical := false)
  _ := aut_gp_fn(pd);
  g := Genus(pd);
  mass := Mass(pd);
  todo := {@pd@}; rss := [];
  cp := Cputime(); ct := 0;
  mass_left := mass;
  hashes := [hash(pd)];
  found_hashes := [];
  used_hashes := {@@};
  cf := cf_fn(pd); // placeholder
  can_forms := []; // I don't think we spend much time comparing them
  while #todo gt 0 and #done lt bd and mass_left gt 0 do
    good_inds := [x: x in [1..#todo]|hashes[x] notin found_hashes];
    ct +:= 1;
    if not silent then
      if ct mod 100 eq 0 then
        printf "%o done, %o found, %o left of which %o hashed, time taken %o\n", ct, #done, #todo, Cputime(cp);
      else vprintf Genus,2: (#good_inds gt 0 select "+" else "*");
      end if;
    end if;
    if #good_inds gt 0 then ind := Random(good_inds);
    else
      // select one at random, but spread things out by taking a hash we
      // haven't used recently
      if #used_hashes ge #Set(hashes) then
        used_hashes := {@@};
        if not silent then vprintf Genus,2: "h"; end if;
      end if;
      ind := random{x: x in [1..#todo]|hashes[x] notin used_hashes};
      Include(~used_hashes,hashes[ind]);
    end if;
    // ind := (#good_inds gt 0 select Random(good_inds) else Random(1,#todo));
    l := todo[ind];
    if find_canonical or #good_inds eq 0 then
      cf := cf_fn(l);
      assert #good_inds eq 0 or cf notin can_forms;
    end if; 
    todo := {@todo[i]: i in Remove([1..#todo],ind)@};
    the_hash := hashes[ind];
    Remove(~hashes,ind);
    new_hash := the_hash notin found_hashes;
    if new_hash then
      is_new := true;
    else
      if not find_canonical then // we have to after all
        cf := cf_fn(l);
        is_new := true;
        for i in [1..#found_hashes] do
          if found_hashes[i] eq the_hash then
            if not IsDefined(can_forms,i) then can_forms[i] := cf_fn(done[i]); end if;
            if can_forms[i] eq cf then is_new := false; break i; end if;
          end if;
        end for;
      end if;
    end if;
    if is_new then
      vprint Lattice: "found new lattice with Gram matrix", Eltseq(GramMatrix(l));
      Include(~done,l);
      if find_canonical or not new_hash then
        can_forms[#done] := cf;
      end if;
      Append(~found_hashes,the_hash);
      vprint Lattice, 2: "computing automorphism group of lattice with Gram matrix", Eltseq(GramMatrix(l));
      ag := aut_gp_fn(l);
      mass_left -:= 1/#ag;
      if not silent then <<a,b,c> where a,b,c is root_sub(l),RealField(5)!(mass_left/mass), #l`AutomorphismGroup>; end if;
      if mass_left eq 0 and find_canonical then
        g`Representatives := done; 
      else
        nlat := {@LatticeWithGram(GramMatrix(n)): n in nb_fn(l,p)@};
        nlat := {@n: n in nlat|n notin done and n notin todo@};
        todo join:= nlat;
        hashes cat:= [hash(i): i in nlat];
      end if;
    end if;
    assert #todo eq #hashes;
  end while;
  if mass_left gt 0 then "warning: finished exploring the graph but still missing", mass_left, "of mass; consider rerunning with larger p"; end if;
  return done,can_forms,g;
end function; */

/*
load "neighbours_canonical.mag";
l := LatticeWithGram(CartanMatrix("d8d8"));
SetVerbose("Lattice",2);
SetVerbose("CanonicalForm",2);
nb := list_genus(l:nb_fn := newNeighbours,aut_gp_fn := AutomorphismGroupFaster);
*/

// Now I will rewrite the function so as not to use the hash function any more
// than necessary.  Eventually I want to allow for improved isomorphism
// testing, which means carrying some additional information around with
// the lattices.  Need to think about how to write the code.

// bd := Infinity(); p := 2; done := {@@}; silent := false; aut_gp_fn := AutomorphismGroupFaster; nb_fn := newNeighbours; cf_fn := func<x|CanonicalForm(GramMatrix(x))>; hash := easy_hash; find_canonical := false;
function list_genus(pd: bd := Infinity(), p := 2, done := {@@}, silent := false, aut_gp_fn := AutomorphismGroupFaster, nb_fn := newNeighbours, cf_fn := func<x|CanonicalForm(GramMatrix(x))>, hash := easy_hash, thorough := true, find_canonical := false)
  if Rank(pd) eq 2 and p eq 2 and IsEven(Determinant(pd)) then
    "warning: cannot run for lattices of rank 2 with even determinant for p = 2";
    return {@pd@},[];
  elif IsEven(Determinant(pd)) and not IsEven(pd) then
    "warning: cannot run for odd lattices with even determinant for p = 2";
    return {@pd@},[];
  end if;
  
  _ := aut_gp_fn(pd);
  g := Genus(pd);
  mass := Mass(pd);
  // should probably be indexed sets, but I doubt that takes most of the time
  hashed := []; unhashed := [pd]; 
  rss := [];
  cp := Cputime(); ct := 0;
  mass_left := mass;
  hashes := []; // hashes of the hashed lattices that may not be new
  done_hashes := [hash(i): i in done];
  known_hashes := {@x: x in done_hashes@}; // hashes of the known lattices
  hashed_inds := [[]: i in known_hashes]; // indices of the hashed lattices in found_lattices
  used_hashes := {@@}; // hashes we have tried already, not to reuse too soon
  can_forms := []; // I don't think we spend much time comparing them
  hash_ind := 0; 
  while #hashed+#unhashed gt 0 and mass_left gt 0 do
    ct +:= 1;
    if not silent then
      if ct mod 100 eq 0 then
        printf "%o done, %o found, %o left of which %o unhashed, time taken %o\n", ct, #done, #hashed+#unhashed, #unhashed, Cputime(cp);
      else vprintf Genus,2: (#unhashed gt 0 select "+" else "*");
      end if;
    end if;
    if #unhashed gt 0 then
      ind := Random(1,#unhashed);
      lat := unhashed[ind];
      // "previously unhashed lattice", Eltseq(GramMatrix(lat));
      Remove(~unhashed,ind);
      h := hash(lat);
      if h notin known_hashes then
        Include(~done,lat);
        vprint Genus,2: "adding lattice", #done, "with new hash";
        Append(~done_hashes,h);
        mass_left -:= 1/#aut_gp_fn(lat);
        if not silent then <<a,b,c> where a,b,c is root_sub(lat),RealField(5)!(mass_left/mass), #lat`AutomorphismGroup>; end if;
        Include(~known_hashes,h);
        Append(~hashed_inds,[]);
        nbs := [LatticeWithGram(GramMatrix(x)): x in nb_fn(lat,p)];
        nbs := [x: x in nbs|x notin hashed and x notin done and x notin unhashed];
        unhashed cat:= nbs;
      else
        Append(~hashed,lat);
        Append(~hashed_inds[Index(known_hashes,h)],#hashed);
      end if;
    else // we only have lattices whose hashes we have completed already
      // this can't loop forever, because there is some lattice left
      repeat
        hash_ind +:= 1;
        if hash_ind eq #hashed_inds+1 then
          hash_ind := 1;
          vprint Genus, 1: "starting over from the beginning of the hash list";
        end if;
      until #hashed_inds[hash_ind] gt 0;
      ind := Random(hashed_inds[hash_ind]);
      h := known_hashes[hash_ind];
      lat := hashed[ind];
      // "previously hashed lattice", Eltseq(GramMatrix(lat));
      // assert hash(lat) eq h;
      Remove(~hashed,ind);
      hashed_inds := [[x-(x lt ind select 0 else 1): x in h|x ne ind]: h in hashed_inds];
      assert forall{i: i in hashed_inds[j], j in [1..#hashed_inds]|hash(hashed[i]) eq known_hashes[j]};
      is_new := true;
      cf := cf_fn(lat);
      for i in [1..#done] do
        if done_hashes[i] eq h then
          if not IsDefined(can_forms,i) then
            can_forms[i] := cf_fn(done[i]);
          end if;
          if cf eq can_forms[i] then
            is_new := false;
            break i;
          end if;
        end if;
      end for;
      if is_new then
        Include(~done,lat);
        vprint Genus, 2: "adding lattice", #done, "with existing hash", hash_ind;
        // "hashes matched:", [x: x in [1..#done_hashes]|done_hashes[x] eq h];
        isom_lat := [x: x in [1..#done-1]|IsIsomorphic(done[x],lat)];
        if #isom_lat gt 0 then // this should never happen
          "??? lattice already known";
          isom_cfs := [can_forms[i]: i in isom_lat];
          "canonical forms match:", [cf eq i: i in isom_cfs];
          "Gram matrices:", [Eltseq(GramMatrix(i)): i in Append([done[x]: x in isom_lat],lat)];
          "already computed canonical forms:", Append(isom_cfs,cf);
          "recomputed canonical forms:", [cf_fn(i): i in Append([done[i]: i in isom_lat],lat)];
          error "something is wrong with the canonical forms";
        end if;
        
        Append(~done_hashes,h);
        mass_left -:= 1/#aut_gp_fn(lat);
        if not silent then <<a,b,c> where a,b,c is root_sub(lat),RealField(5)!(mass_left/mass), #lat`AutomorphismGroup>; end if;
        nbs := [LatticeWithGram(GramMatrix(x)): x in nb_fn(lat,p)];
        nbs := [x: x in nbs|x notin hashed and x notin done and x notin unhashed];
        unhashed cat:= nbs;
      end if;
    end if;
  end while;

  error if mass_left lt 0, "exhausted more mass than exists";
  if mass_left gt 0 then
    "warning: failed to exhaust the genus; try again with larger p";
  end if;
  return done, done_hashes;
end function;

intrinsic GenusRepresentativesFaster(pd::Lat : bd := Infinity(), p := 2, done := {@@}, silent := false, aut_gp_fn := AutomorphismGroupFaster, nb_fn := newNeighbours, cf_fn := func<x|CanonicalForm(GramMatrix(x))>, hash := easy_hash, thorough := true, find_canonical := false) -> SeqEnum
{Find the representatives of the genus of the lattice pd.}
    return list_genus(pd: bd := bd, p := p, done := done, silent := silent, aut_gp_fn := aut_gp_fn, nb_fn := nb_fn, cf_fn := cf_fn, hash := hash, thorough := thorough, find_canonical := find_canonical);
end intrinsic;

