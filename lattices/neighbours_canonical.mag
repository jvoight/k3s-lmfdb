// function to enumerate a genus using canonical forms
Z := Integers();
Q := Rationals();
load "aut-char.mag";
Attach("canonical_form.m");
Attach("my_neighbors.m");

// A very quick lattice hash.  This is better with a faster
// OrthogonalDecomposition (cf. my email)
function root_sub(lat)
  rl := {*Strings()|*};
  tor := [];
  sl := sub<lat|[x[1]: x in ShortVectors(lat,2,2)]>;
  Zn := RSpace(Z,Dimension(lat));
  slzn := sub<Zn|[Eltseq(i): i in ShortestVectors(lat)]>;
  tor := Moduli(Saturation(slzn)/slzn);
  od := OrthogonalDecomposition(sl);
  for i in od do
    sdi := IntegerToString(Dimension(i));
    for l in ["A","D","E"] do
      if IsIsomorphic(i,LatticeWithGram(CartanMatrix(l*sdi))) then
        Include(~rl,l*sdi);
        continue i;
      end if;
    end for;
    error "impossible root lattice", Eltseq(GramMatrix(lat));
  end for;
  return rl,tor,#ShortVectors(lat,4,4);
end function;

// Function to enumerate the p-neighbourhood of a lattice using the
// canonical form of DS-H-V-vW, as implemented in canonical_form.m.
// Arguments:

// pd: the lattice
// bd: stop after considering this number of lattices
// p: the prime for p-neighbours
// done: initial list of lattices in the genus
// silent: stops the code from babbling (overridden by "show")
// aut_gp_fn, nb_fn, cf_fn: custom functions for finding Aut(L),
// the p-neighbours of a lattice, and a canonical form
// thorough included for backward compatibility

// bd := Infinity(); p := 2; done := {@@}; silent := false; aut_gp_fn := aut_faster; nb_fn := newNeighbours; cf_fn := func<x|CanonicalForm(GramMatrix(x))>; hash := func<x|<IsEven(x) select "even" else "odd",a,b,c,d,#aut_gp_fn(x),ThetaSeries(x,(IsEven(x) select 20 else 10))> where a,b,c is root_sub(x) where d is [Rank(stoi(x,i)): i in [1..6]]>; find_canonical := false;
stoi := func<l,i|sub<l|[x[1]: x in ShortVectors(l,i)]>>;
easy_hash := func<x|<IsEven(x) select "even" else "odd",a,b,c,d,/*#aut_faster(x),*/ThetaSeries(x,(IsEven(x) select 20 else 10))> where a,b,c is root_sub(x) where d is [Rank(stoi(x,i)): i in [1..6]]>;
// further improvement: only compute canonical form when we need it,
// unless find_canonical is set to true
function list_genus(pd: bd := Infinity(), p := 2, done := {@@}, silent := false, aut_gp_fn := AutomorphismGroup, nb_fn := Neighbours, cf_fn := func<x|CanonicalForm(GramMatrix(x))>, hash := easy_hash, thorough := true, find_canonical := false)
  _ := aut_gp_fn(pd);
  g := Genus(pd);
  mass := Mass(pd);
  todo := {@pd@}; rss := [];
  cp := Cputime(); ct := 0;
  mass_left := mass;
  hashes := [hash(pd)];
  found_hashes := [];
  used_hashes := {@@};
  cf := cf_fn(pd); // placeholder
  can_forms := []; // I don't think we spend much time comparing them
  while #todo gt 0 and #done lt bd and mass_left gt 0 do
    good_inds := [x: x in [1..#todo]|hashes[x] notin found_hashes];
    ct +:= 1;
    if not silent then
      if ct mod 100 eq 0 then
        printf "%o done, %o found, %o left, time taken %o\n", ct, #done, #todo, Cputime(cp);
      else printf (#good_inds gt 0 select "+" else "*");
      end if;
    end if;
    if #good_inds gt 0 then ind := Random(good_inds);
    else
      // select one at random, but spread things out by taking a hash we
      // haven't used recently
      ind := random{x: x in [1..#todo]|hashes[x] notin used_hashes};
      Include(~used_hashes,hashes[ind]);
      if #used_hashes eq #Set(hashes) then
        used_hashes := {@@};
        if not silent then printf "h"; end if;
      end if;
    end if;
    // ind := (#good_inds gt 0 select Random(good_inds) else Random(1,#todo));
    l := todo[ind];
    if find_canonical or #good_inds eq 0 then cf := cf_fn(l); end if; 
    assert #good_inds eq 0 or cf notin can_forms;
    todo := {@todo[i]: i in Remove([1..#todo],ind)@};
    the_hash := hashes[ind];
    Remove(~hashes,ind);
    new_hash := the_hash notin found_hashes;
    if new_hash then
      is_new := true;
    else
      if not find_canonical then // we have to after all
        cf := cf_fn(l);
        is_new := true;
        for i in [1..#found_hashes] do
          if found_hashes[i] eq the_hash then
            if not IsDefined(can_forms,i) then can_forms[i] := cf_fn(done[i]); end if;
            if can_forms[i] eq cf then is_new := false; break i; end if;
          end if;
        end for;
      end if;
    end if;
    if is_new then
      Include(~done,l);
      if find_canonical or not new_hash then
        can_forms[#done] := cf;
      end if;
      Append(~found_hashes,the_hash);
      ag := aut_gp_fn(l);
      mass_left -:= 1/#ag;
      if not silent then <<a,b,c> where a,b,c is root_sub(l),RealField(5)!(mass_left/mass), #l`AutomorphismGroup>; end if;
      if mass_left eq 0 and find_canonical then
        g`Representatives := done; 
      else
        nlat := {@LatticeWithGram(GramMatrix(n)): n in nb_fn(l,p)@};
        nlat := {@n: n in nlat|n notin done and n notin todo@};
        todo join:= nlat;
        hashes cat:= [hash(i): i in nlat];
      end if;
    end if;
    assert #todo eq #hashes;
  end while;
  if mass_left gt 0 then "warning: finished exploring the graph but still missing", mass_left, "of mass; consider rerunning with larger p"; end if;
  return done,can_forms,g;
end function;

/*
load "neighbours_canonical.mag";
l := LatticeWithGram(CartanMatrix("d8d8"));
SetVerbose("Lattice",2);
SetVerbose("CanonicalForm",2);
nb := list_genus(l:nb_fn := newNeighbours,aut_gp_fn := aut_faster);
*/

// Unfortunately the CanonicalForm intrinsic that comes with Magma
// is not genuinely canonical.
// Here are two 11 x 11 Gram matrices that define isomorphic lattices:
/*bad_mats := [[ 2, 0, 1, -1, -1, -1, -1, -2, -1, -1, -1, 0, 4, -1, 1, 0, 0, 0, 1, 0, 0, -1, 1, -1, 2, -1, 0, 0, 0, -2, 0, 0, 0, -1, 1, -1, 2, 1, 1, 1, 2, 1, 1, -1, -1, 0, 0, 1, 3, 2, 2, 1, 1, 1, 1, -1, 0, 0, 1, 2, 3, 1, 2, 1, 2, 2, -1, 0, 0, 1, 2, 1, 3, 1, 2, 1, 0, -2, 1, -2, 2, 1, 2, 1, 5, 2, 2, 2, -1, 0, 0, 1, 1, 1, 2, 2, 3, 2, 1, -1, 0, 0, 1, 1, 2, 1, 2, 2, 3, 2, -1, -1, 0, -1, 1, 2, 0, 2, 1, 2, 6 ],
             [ 2, 1, -1, -1, -1, 0, 0, 1, -1, -2, -2, 1, 2, -1, 0, 0, 0, 0, 1, 0, 0, 0, -1, -1, 2, 1, 1, 0, 0, 0, 1, 2, 2, -1, 0, 1, 3, 2, 1, -1, 0, 2, 2, 3, -1, 0,1, 2, 3, 0, -1, 0, 2, 3, 3, 0, 0, 0, 1, 0, 2, -1, 0, 0, -3, -2, 0, 0, 0, -1,-1, -1, 2, 0, -1, 2, 2, 1, 1, 0, 0, 0, 0, 0, 4, 0, 0, 0, -1, 0, 1, 2, 2, 0, -1, 0, 3, 3, 3, -2, 0, 2, 2, 3, -3, 2, 0, 3, 12, 11, -2, 0, 2, 3, 3, -2, 2, 0, 3, 11, 12 ]];
bad_lats := [LatticeWithGram(Matrix(11,11,i)): i in bad_mats];
assert IsIsomorphic(bad_lats[1],bad_lats[2]);
assert CanonicalForm(bad_lats[1]) ne CanonicalForm(bad_lats[2]);
*/
// Update: it now works, using the new intrinsic in canonical_form.m.

// a lattice that causes problems for the canonical form:
// badl := LatticeWithGram(Matrix([[2,1,1,-1,-1,1,-1,-1,0,1,1,2,1,1,0,2],[1,2,1,-1,-1,1,-1,0,0,0,0,2,1,1,0,2],[1,1,2,-1,-1,1,-1,-1,-1,1,1,2,1,1,0,2],[-1,-1,-1,2,1,-1,1,1,1,0,0,-2,-1,-1,0,-2],[-1,-1,-1,1,2,-1,1,0,1,-1,-1,-2,-1,-1,0,-2],[1,1,1,-1,-1,2,-1,0,-1,0,0,2,1,1,0,2],[-1,-1,-1,1,1,-1,2,0,1,0,0,-2,-1,-1,0,-2],[-1,0,-1,1,0,0,0,4,1,-1,-1,-1,0,-1,0,0],[0,0,-1,1,1,-1,1,1,4,0,0,-1,0,-1,0,-2],[1,0,1,0,-1,0,0,-1,0,4,3,1,0,0,1,1],[1,0,1,0,-1,0,0,-1,0,3,4,1,0,0,1,1],[2,2,2,-2,-2,2,-2,-1,-1,1,1,4,2,2,0,3],[1,1,1,-1,-1,1,-1,0,0,0,0,2,2,1,0,1],[1,1,1,-1,-1,1,-1,-1,-1,0,0,2,1,2,0,1],[0,0,0,0,0,0,0,0,0,1,1,0,0,0,2,0],[2,2,2,-2,-2,2,-2,0,-2,1,1,3,1,1,0,6]]));
